/*
 * 	 연산자
 * 	 ----
 * 	   단항연산자
 * 		-증감연산자 (++, --)
 * 		-부정연산자	(!) 
 * 		-형변환연산자 (type)
 * 	   이항연산자
 * 		-산술연산자 (+, -, *, /, %) -> 가장 많이 사용되는 연산자
 * 		-비교연산자	 (==, !=, <, >, <=, >=)
 * 		-논리연산자 (&&, ||)
 * 		-대입연산자 (=, +=, -=)
 *	   삼항연산자
 *		-(조건)? 값 : 값;
 *
 * 	   * 제어문 관련 --> 부정, 비교, 논리 (조건문, 반복문) boolean형식
 * 		 연산 + 제어
 * 
 * 
 * 	 page 91 (연산자 우선순위)
 * 	   단항연산자 -> 산술연산자 -> 비교연산자 -> 논리연산자 -> 대입연산자
 * 	 page 91~92
 * 	   산술변환
 * 		-> 연산은 항상 같은 타입끼리 연산
 * 		   ====================== 같은 데이터형으로 변경후 연산처리 (자동형변환:큰 데이터형으로 변경)
 *		   int + double 
 *		   ---
 *		  double + double = double (자동 형변환)
 *
 *		   사용자(프로그래머)가 변경 --> 강제 형변환
 *		   int + (int)double = int
 *
 *   	   int 이하 데이터형 (byte, char)은 int로 변환
 *		   byte + byte = int
 *		   char + char = int
 *		   byte + char = int ..
 *		   * int / int = int / int / double --> 소수점 인식
 *
 *	 page 93
 *	   단항연산자
 *		++, --
 *	   전치 (++a) : 증가된 값 대입
 *	   후치 (a++) : 대입하고 나중에 증가
 *
 *	 page 96 음수/양수 -
 *	   
 *	 page 97 산술연산자
 *   --> 산술변환이 있다 (데이터형이 같은 것만 연산 -> 큰데이터형으로 변경) - 필요시에만 강제로 변환
 *   	 / (0으로 나눌수 없다) --> (오류처리)
 *   	 % (부호가 왼쪽부호를 따라 간다)
 *   	 작은 데이터형으로 연산 결과를 받는 경우의 문제점 --> 오버플로우를 발생할 수 있다 (저장 범위를 벗어난다)
 *   
 *   page 109 비교연산자 (결과값은 무조건 boolean)
 *   --> ==, !=, <, >, <=, >=
 *   
 *   page 114 논리연산자 (결과값 무조건 boolean)
 *   --> && : 범위가 포함
 *   		  (조건) && (조건)
 *   	 || : 범위가 미포함
 *   		  (조건) || (조건)
 *   page 118 [효율적인 연산]
 *   
 *   page 130 삼항연산자
 *   	 (조건) ? 값1 : 값2
 *   	  조건이 true이면 값1, false면 값2
 *   	    
 *   page 132 대입연산자
 *   --> =, (+=, -=, /= : 복합대입연산자)
 *   	 int a = 10;
 *   	 a += 1; --> a = a + 1;
 *   	 a -= 1; --> a = a - 1;
 *   	 a /= 5; --> a = a / 5;
 *   
 *
 *
 *
 */
public class 연산자정리 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
	}

}
